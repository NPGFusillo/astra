import os
from astra.database import astradb
from astra.tasks.io import ApStarFile
from astra.tasks.continuum import Sinusoidal
from astra.tasks.targets import DatabaseTarget, LocalTarget, AstraSource
from astra.contrib.thecannon.tasks.test import EstimateStellarLabelsGivenApStarFileBase


class ContinuumNormalize(Sinusoidal, ApStarFile):

    """
    A pseudo-continuum normalisation task for spectra in ApStarFiles
    using a sum of sines and cosines to model the continuum.
    """

    # Row 0 is individual pixel weighting
    # Row 1 is global pixel weighting
    # Row 2+ are the individual visits.

    # We will analyse all spectra.

    def requires(self):
        return ApStarFile(**self.get_common_param_kwargs(ApStarFile))

    def output(self):
        """The outputs generated by the task."""

        if self.is_batch_mode:
            return (task.output() for task in self.get_batch_tasks())

        # TODO: Put this to AstraSource ?
        is_apogee = getattr(self, "apred", None) is not None
        reduction_version = self.apred if is_apogee else self.run2d
        path = os.path.join(
            self.output_base_dir,
            f"star/{self.telescope}/{int(self.healpix)/1000:.0f}/{self.healpix}/",
            f"Continuum-{reduction_version}-{self.telescope}-{self.obj}-{self.task_id}.pkl",
        )
        os.makedirs(os.path.dirname(path), exist_ok=True)

        return LocalTarget(path)


class EstimateStellarLabelsGivenApStarFile(
    EstimateStellarLabelsGivenApStarFileBase, ContinuumNormalize
):
    @property
    def task_short_id(self):
        return f"{self.task_namespace}-{self.task_id.split('_')[-1]}"

    def requires(self):
        requirements = super(EstimateStellarLabelsGivenApStarFile, self).requires()
        requirements.update(
            {
                "observation": ApStarFile(**self.get_common_param_kwargs(ApStarFile)),
                "continuum": ContinuumNormalize(
                    **self.get_common_param_kwargs(ContinuumNormalize)
                ),
            }
        )
        return requirements

    def output(self):
        """The outputs generated by the task."""

        if self.is_batch_mode:
            return (task.output() for task in self.get_batch_tasks())

        return {
            "AstraSource": AstraSource(self),
            "database": DatabaseTarget(astradb.TheCannon, self),
        }
