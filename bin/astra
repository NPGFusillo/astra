#!/usr/bin/env python3
import click

# Common options.
@click.group()
@click.option("-v", "verbose", default=False, is_flag=True, help="verbose mode")
@click.pass_context
def cli(context, verbose):
    context.ensure_object(dict)
    context.obj["verbose"] = verbose
    # Overwrite settings in ~/.astra/astra.yml
    # from astra import log
    # log.set_level(10 if verbose else 20)


@cli.command()
@click.option("--drop-tables", is_flag=True)
def initdb(drop_tables):
    """Initialize the database."""
    from time import sleep
    from astra.utils import log
    from astra.models import (
        base,
        apogee,
        #apogeenet,
        aspcap,
        #boss,
        #classifier,
        #lineforest,
        madgics,
        #mdwarftype,
        #slam,
        #snow_white,
        source,
        spectrum,
        #the_payne
    )
    
    models = base.BaseModel.__subclasses__()
    with base.database.atomic():
        if drop_tables:
            log.warning(f"Dropping database tables in 10 seconds..")
            sleep(10)
            base.database.drop_tables(models)
        
        base.database.create_tables(models)
    log.info(f"Created {len(models)} database tables: {models}")
    
    return None


@cli.command()
@click.argument("paths", nargs=-1)
def run(paths, **kwargs):
    """Execute one or many tasks."""
    import os
    import json
    from importlib import import_module
    from astra.utils import log, expand_path
    from astra.database.astradb import DataProduct
    from tqdm import tqdm

    for path in paths:
        log.info(f"Running {path}")
        with open(path, "r") as fp:
            content = json.load(fp)
         
        instructions = [content] if isinstance(content, dict) else content
        N = len(instructions)
        for i, instruction in enumerate(instructions, start=1):
            log.info(f"Starting on instruction {i}/{N} in {path}")

            task_kwargs = instruction.get("task_kwargs", {})

            # A couple of unfortunate hacks to fix instructions that were incomplete.
            if (instruction["task_callable"] == "astra.contrib.aspcap.abundances.aspcap_abundances"):
                if "pwd" not in task_kwargs:
                    # This one will fail.
                    log.warning(f"Skipping {i}-th (1-indexed) instruction because it's ASPCAP abundances without a pwd")
                    continue
                
                # Check if outputs already exist.
                pwd = task_kwargs["pwd"]
                if os.path.exists(os.path.join(expand_path(pwd), "stdout")):
                    log.warning(F"Skipping {i}-th (1-indexed) instruction because it's ASPCAP abundances and the outputs already exist")
                    continue            

            # Get the task executable.
            module_name, function_name = instruction["task_callable"].rsplit(".", 1)
            module = import_module(module_name)
            task_callable = getattr(module, function_name)

            has_data_products = "data_product" in task_kwargs # TODO: this special key should be defined elsewhere
            if has_data_products:
                # Resolve the data products
                input_data_products = task_kwargs.pop("data_product", [])
                if isinstance(input_data_products, str):
                    input_data_products = json.loads(input_data_products)
                # The same data product can appear in this list multiple times, and we want to preserve order.
                q = DataProduct.select().where(DataProduct.id << input_data_products)
                unique_data_products = { dp.id: dp for dp in q }
                task_kwargs["data_product"] = [unique_data_products[dp_id] for dp_id in input_data_products]
                
            log.info(f"Executing..")
            try:
                results = task_callable(**task_kwargs)
                for result in results:
                    None
            except:
                log.exception(f"Exception in {task_callable} with {task_kwargs}")
                raise
                continue


    log.info(f"Done")
    
    # Remove the path now that we're done.
    #try:
    #    os.unlink(path)
    #except:
    #    None



if __name__ == "__main__":
    cli(obj=dict())
